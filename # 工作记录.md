# 工作记录
## 3/5 16:00 安装好了EBPF相关环境
工具目录 /usr/share/bcc/tools
执行环境 python3 

环境依赖
LLVM 3.7.1 或更高版本，编译时支持 BPF（默认=on）
Clang，由与 LLVM 相同的树构建
cmake (>=3.1)、gcc (>=4.7)、flex、bison
LuaJIT

依赖安装
~~~
# Trusty (14.04 LTS) and older
VER=trusty
echo "deb http://llvm.org/apt/$VER/ llvm-toolchain-$VER-3.7 main
deb-src http://llvm.org/apt/$VER/ llvm-toolchain-$VER-3.7 main" | \
  sudo tee /etc/apt/sources.list.d/llvm.list
wget -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -
sudo apt-get update

# For Bionic (18.04 LTS)
sudo apt-get -y install bison build-essential cmake flex git libedit-dev \
  libllvm6.0 llvm-6.0-dev libclang-6.0-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils

# For Eoan (19.10) or Focal (20.04.1 LTS)
sudo apt install -y bison build-essential cmake flex git libedit-dev \
  libllvm7 llvm-7-dev libclang-7-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils
  
# For Hirsute (21.04)  or Impish (21.10)
sudo apt install -y bison build-essential cmake flex git libedit-dev   libllvm11 llvm-11-dev libclang-11-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils

# For other versions
sudo apt-get -y install bison build-essential cmake flex git libedit-dev \
  libllvm3.7 llvm-3.7-dev libclang-3.7-dev python zlib1g-dev libelf-dev python3-distutils

# For Lua support
sudo apt-get -y install luajit luajit-5.1-dev
~~~

bcc编译安装， 若llvm版本小于11需要切换为v0.24.0
~~~
git clone https://github.com/iovisor/bcc.git
mkdir bcc/build; cd bcc/build
cmake ..
make
sudo make install
cmake -DPYTHON_CMD=python3 .. # build python3 binding
pushd src/python/
make
sudo make install
popd
~~~


## 3-6 16:00 能hello world了 很不容易
重点代码
~~~python
# 把一个c函数放在一个字符串，声明一个BPF并设置其text为这个字符串
prog2 = """
int hello(void *ctx){
    bpf_trace_printk("hello world!\\n");
    return 0;
}
"""
c = BPF(text = prog2)

# 事件函数
clone = c.get_syscall_fnname("clone") # plan a
# 也可以不采用这个方案，把之前的c函数声明为kprobe__事件函数名也可以
c.attach_kprobe(event = open, fn_name="wello")

# 输出方案
c.trace_print() # plan a
# or plan b
(task, pid, cpu, flags, ts, msg) = c.trace_fields()
print("%-18.9f %-16s %-6d %s" % (ts,task,pid,msg))

~~~

## 3-9 迷人的bug出现了
解决了这个bug，实际上是由于**get_syscall_fnname()**没能获取到真正的系统调用，因此没有跟踪，这里需要多查

## 3-10 kretprobe
能获得返回值了，并且定位了获取命令comm 以及文件名需要的
~~~python
from bcc import BPF

prog ="""
#include <uapi/linux/limits.h>
#include <linux/sched.h>
#include <uapi/linux/openat2.h>

typedef struct event_data_t{
    u32 pid;
    u32 ret;
    char comm[TASK_COMM_LEN];
    char fname[NAME_MAX];
}event;

typedef struct val_t{
    u64 id;
    const char *fname;
}val;

BPF_HASH(infotmp, u64, val); // 保存中间结果的hashmap
BPF_PERF_OUTPUT(open_events);

int trace_syscall_open(struct pt_regs *ctx, int dfd, const char __user *filename, int flags) // 没有这个 int dfd不显示filename，很尬
{
    val v = {};
    u64 id = bpf_get_current_pid_tgid();
    v.id = id;

    // bpf_probe_read(&v.fname, sizeof(v.fname), (void *)filename);
    v.fname = filename;

    infotmp.update(&id, &v);

    return 0;
}

int trace_syscall_open_return(struct pt_regs *ctx)
{
    u64 id = bpf_get_current_pid_tgid();
    val *vp;
    event evt = {};

    vp = infotmp.lookup(&id);
    if(vp == 0)
    {
        return 0;
    }

    evt.pid = id>>32;
    evt.ret = PT_REGS_RC(ctx); // 读取结果

    bpf_probe_read(&evt.fname, sizeof(evt.fname), (void *)vp->fname);
    bpf_get_current_comm(&evt.comm, sizeof(evt.comm));  // 3.4 读取当前进程的 commandline 至结构体中
  
    open_events.perf_submit(ctx, &evt, sizeof(evt));
  
    infotmp.delete(&id);  // 3.4 完成跟踪删除中间结果
    return 0;
}


"""

b = BPF(text=prog)
# syscall = b.get_syscall_fnname("open")
# print(syscall)
b.attach_kprobe(event="do_sys_open", fn_name="trace_syscall_open")
b.attach_kretprobe(event="do_sys_open", fn_name="trace_syscall_open_return") # 1. add

# b.attach_kprobe(event=syscall,fn_name="trace_syscall_open")
print("%-16s %-6s %-64s return" % ( "COMM", "PID", "FILE"))
start = 0

# process event
def print_event(cpu, data, size):
    event = b["open_events"].event(data)
    print("%-16s %-6d %-64s %d" % (event.comm, event.pid, event.fname,event.ret))


# loop with callback to print_event
b["open_events"].open_perf_buffer(print_event)

i = 10
while (i>0):
    try:
        i -= 1
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()

~~~

## 3-11 TRACEPOINT_PROBE以及perf工具
perf 工具 需要su下用，不然看不到很多东西，注意
在解决__x64_sys_open没有输出之前，不要用


## 3-21 未来设计
现阶段成果还不错，暂时停止一段时间准备考研复试，预计4月继续开始
下一阶段TODO:
- [ ] 实现对特定程序进行系统调用追踪并记录，记录追踪程序开销等
- [ ] 基于上一条内容，将记录的程序的系统调用向量化，利用得到的向量进行分类
- [ ] 完成论文内容
- [ ] more